# Начинать имя переменной нельзя с цифры  и спец. знаков
# int-целочисленные числа
# str-строки, текст, НЕИЗМЕНЯЕМЫЙ ТИП ДАННЫХ
# float-вещественные числа
# bool-имеет 2 значения, True или Folse
# Экранирование- когда мы ставим \ перед ", кавычка не воспринимается как команда. Или можно использовать разные кавычки
# Динамическая типизация- тип переменной определяется в момент присваивания
# В python переменные не хранят обьекты, а ссылаются на них
# Каскадное присваивание a = b = c = 0
# Множественное присваевание a, b, c = 1, 2, 3
fnmber = 7
number = 5.7
name = "Abraham"
sttats = True
print("Что нужно вывести на экран")
print(12345)
print(name)
print("Он \"плохой\" человек!")
print('Ну вот как то "ТАК"')

# Чтобы перевести текст на новую строку используем \n
print("Это было давным давно.\nБыл очень черный день.")
print('''Такие интересные кавычки позволяют сразу записыать тест,
как?
Правильно, с переходом строк''')
# Конкатенация
# Нельзя конкатенировать разные типы данных
# Можно сконвертировать один тип данных в другой
print("Ну привет " + name + ".")
print("Мне " + str(fnmber) + " годиков")

# Если мы хотим спросить что-то у пользователя используем input и сразу записываем в переменную
# Все что возвращает input, является строкой
print(num := int(input()))  # Оператор walrus(:=) позволяет выполнить опперации сразу
name = input("Введите свое имя: ")
age = input("Сколько вам годиков? ")

# print("Привет "+name+", которому "+age) Способ вывода
# print("Мееня зовут {0}, мне {1}".format(name, age)) метод вывода
# print('Мееня зовут {fio}, мне {old}'.format(fio=name, old=age))
# print(f"Ну здарова {name}") f""- F строки, их используют для упрощения кода, внутри скобок можно использовать методы

# print("Привет", name, sep="*") sep- разделитель между данными
# print("Привет", end=" ") end-вместо символа конца строки, выводится то что мы укажем

# 'meet' in 'nice to meet you' показывает есть ли фрагмент в тексте
# print(ord('c')) ord - показывает код символа

# +,-,*,/,**-Возведение в степень,//-Деление без остатка, Унарный минус, округление, Пи
a = 5
b = 10
# c=a+b
# c=a-b
# c=a*b
# c=a/b
# c=a**2
# c=b%3 #Возвращется остаток
c = b // 3  # Деление нацело
print(c)

# abs(-5) Выведет 5, abs- выводит модуль чиса
# min(0, 2, 0, 4, 6) Вычисляет минимальное среди перданных чисел, max- противоположенная ей
# pow(3, 6) Возводит число в степень


# Унарный минус
k = 5
k = -k  # К переменной k присваиваем само себя, и меняем знак
# k=-k Если используем еще раз, то получим положительное число
print(k)

# Округление
n = 5.65
print(round(n))  # round- округляет(есть особенность, функция иногда округляет в большую сторону, а иногда в меньшую)
# print(round(4.552324, 2)) Функция округлит число до сотых
# print(round(5.54534455234, -1)) Округлит до десятков

import math  # импортируем модуль

j = 2.75
print(math.floor(j))  # floor- функция для принудительного округления числа в меньшуу сторону
# math.ceil-округляет в большуу сторону
print(math.pi)  # Для точного вывода числа пи, но оно ограничивается точностью вещественного числа в пайтоне
import time  # импортируем модуль

time.sleep(5)  # time.speep- иммитируем задержку

o = input("Введем что-нибудь: ")  # input-используем чтобы дать пользователю ввести какое дибо значение в переменную
print(o)

# Списки
A = [1, 3, 4]  # Тип list- список, он изменяемый
print(type(A))
# Как и над строками, над списками можно проводить операции сложения и умножения
A[0] = 6  # Элемент любого индекса можно переназначить
print(A[0])  # Элемент списка может быть вызван, указанием его индекса в кв. скобках
A.append(12)  # Добавляем в конец списка обьект, сразу меняя его
A.insert(2, 'is')  # Позволяет вставить новый элемент на любую позицию в списке
print(3 in A)  # Чтобы проверить наличие в спике какого-либо элемента, используем оператор in
print(len(A))  # Чтобы подсчитать количество элементов в списке
letters = list(test)  # делает из строки список
letters = ['p', 'l', 'i', 'z', ' ', 'h', 'e', 'l', 'p']
print(letters.index('p'))  # С помощью метода index можно найти первое упоминание элементав спискеи вывести его индекс
print(max(letters))  # Возвращает элемент с максиматьльным знаением
print(min(letters))  # Возврвщает элемент с минимальным значением
t = [27, 45, 34, 35, 36]
print(sum(t))  # позволяет вычислить умму элементов
print(sorted(t))  # сортирует значения по возрастанию, возвращает новый список
print(sorted(t, reverse=True))  # сортировка по убыванию
print(t.sort())  # Сортирует, меняет список
# комадны +, * можно ипользоват со списками
print(t[1:3])  # срез в списке
copi = t[:]  # создаст копию списка
copi[::-1]  # перебираем список с конца в начало

print(letters.count('p'))  # Возвращает количество упоминаний элемента в списке
print(letters.remove('i'))  # Удаляет обьект из списка(один обьект по порядку, не все)
print(letters.pop(3))  # выводит значение удаленного из списка элемента, по индексу, если индекс не указывать, то выведет и удалит последний элемент списка
print(letters.reverse())  # Распологает элементыв обратном порядке
", ".join(letters)  # из списка делает строку, соединяя элементы, в данном случае, через ", "

m = [
    [1, 2, 3],
    [4, 5, 6]
]  # Вложенные списки могут представлять двумерную матрицу
print(m[1][2])
# Некоторые типы данных, такте как строки, могут быть проиндексированы, как списки
str = "hello"
print(str[2])

# Цикл while
x = 123
while x > 5:  # Пока x больше 5 выполняется цикл
    print(x)
    x -= 1  # Запись, аналогичная x=x-1
    # x-=1 - это декремент; x+=1 - это инкремент

pas = "MACK"
p = ""
while p != pas:
    p = input("Введите пароль: ")
print("Вы вошли в систему")  # прикольный пример работы
# break - мнгновенное завершение цикла, continue - завершает итераци, цикл сразу переходит к новой
# можно использовать else, выполнится после штатного окончания цикла

# Однократное выполнение тела цикла называется итерацией

# Цикл for
for NiceFun in range(1, 100, 3):  # range(start, stop, step) от какого значения до какого и с каким шагом
    print(NiceFun)
# Если step=1 то его можно не указывать

# if x>5 - если x>5 то выполняем команды
# elif - тоже самое что и if
# else - если друге
# Есть 3 логических опперации and-и; or-или; not-нет.

# Множественное присваивание
x, y, z = 1, 2, 3
print(x, y, z)

# Меняем значения переменных
x, y = y, x
print(x, y)


# def- команда создания функций
# Начало заголовка функции
def hello_n(name: str,
            n: int):  # Аннотация типов- это когда мы кладем определенный тип данных в переменную, например, name: str
    # Конец заголовка функции
    # Начало тела функции
    for i in range(n):  # Вместо range можно указать какой нибудь иттерируемый обьект
        print(name)


# Конец тела функции
hello_n('Вася', 5)  # Вызываем функцию и присваиваем переменным name и n какие то значения

# Функция range- это иттерируемый обьект, генератор аррифметической прогрессии
A = range(1, 6, 1)
print(A[3])  # Выведет 3 элемент прогрессии
print(*A)  # Выведет всю последовательность, распечатываем A

# Строки
text = "ну посмотрим что и как работет"
print(text[-1])  # вывет последний элемент строки
print(r"\\\\n\t\a")  # R строки будут воспроизводиться ровно так, как запискны
print(text[
      0:12])  # строка[start:stop:step] - такая конструкция называется срез, выведет от 0 индекса и до 12 не включительно
# если не указать стоп то выведется от начального индекса до конца строки, то же самое со стартом
# так же можно указать шаг, и если он будет отрицательный то функция пойдет от конечного индекса к начальному

print(text.split()[0])  # разделяем строку по пробелам и преобразуем в список
print(text.upper())  # делает все маленькие буквы заглавными
print(text.lower())  # переводит все буквенные символы в нижний реизистор
print(text.count("от", 3,
                 30))  # возвращает число повторений подстроки, можно указать с какого индекса по какой проверяется, можно не указывать
print(text.find("по", 0,
                30))  # показывает первый индекс  вхождения фрагмента, если не находится подстрока, то возвращается -1
print(text.rfind("по"))  # ищет посдстроку с конца
print(text.index("по"))  # работает точно так же как find, но при отсутствии подстроки, выдает ошибку
print(text.replace("п", "А", 3))  # заменит подстроку на другую, и можем указать максимальное число замен
print(text.isalpha())  # выведет true если строка полностью состоит из букв
print(text.isdigit())  # выведет true если строка полностью состоит из цифр
print(text.rjust(40,
                 "0"))  # делает так, чтобы строка содержала 40 символов, добавляет символы заполнители, если укажем количество символов меньше чем в строке, о получим ту же самую строку
print(text.ljust(40, "1"))  # добавляет символы справа
"  yes yes yes    \n".strip()  # удалит незначащие символы в конце и начале строки rsplit-удаляет справа, lsplit-удаляет слева

# В кортеж и лист можно класть данные разного типа, в отличии от массива
# Кортеж занимает меньше памяти чем список

a = 5
b = 6
var = print(abs(a)) if a > b else print(abs(b))  # Тернарное условие
print(f"У нас имеется число {a} " + "и оно " + ("четное" if a % 2 == 0 else "нечетное"))

# Итератор
d = [16, 45, 225, 899, 1235]
it = iter(d)
print(next(it))  # next прходит 1 раз по каждому элементу иторатора, так не явно работает for

# Вложенные цыклы
# В тексте де встречаются двойные пробелы, нужно заменить их на одинарные
t = ["Скажи-ка дядя  ведь не даром",
     "Москва  спаленная пожаром",
     "Французу  отдана"]
for i, line in enumerate(t):
    while line.count("  "):
        line = line.replace("  ", " ")

    t[i] = line
print(t)

# В следующем примере выполняем транспонирование матрицы ( повторить и понять )
matr = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]

for i in range(len(matr)):
    for j in range(i + 1, len(matr)):
        matr[i][j], matr[j][i] = matr[j][i], matr[i][j]

for r in matr:
    for x in r:
        print(x, end="\t")
    print()

# Генераторы списков
M, N = 5, 6
a = [x ** 2 for x in range(N)]  # [<способ формирования значения> for <переменная> in <итерируемый обьект>]
a = [i for i in range(-10, 10, 2) if i % 2 == 0]
a = [[x for x in range(M)] for i in range(N)]  # вложеный генератор отрабатывает после внешнего цикла

# Транспонированная матрица при помощи генератора списков
matr = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
matr = [[row[i] for row in matr] for i in range(len(matr))]

# dict - словари
D = {'babka': 123,  # Словари состоят из пар, ключа+знначение
     'papa': 27,
     'brat': 12}
D['ded'] = 23  # Добавляем новую пару в словарь

D['babka']  # выведет значинние ключа
# если в словаре будет нескольео одинаковых ключей, с одинаковым значением, то при использовании ключа, ввыведет последнее его значение в словаре

len(D)  # выведет длинну словаря
del (D['ded'])  # удалит ключ с его значением
'ded' in D  # проверит, есть ли ключ в словаре, этим методом нельзя проверять значения

dict(one=1, two=2, tree='3', four='4')  # функция для записи словарей

# функцию dict можно использовать что бы преобразовать строку с вложенными сроками в словари:
family = [['дед', 'бабка'], ['мать', 'отец']]
dict(family)

lst = ['fuf', 'xix', 'puf', "xm"]
G = dict.fromkeys(lst)  # создаст словарь с неопределенными значениями
K = dict.fromkeys(lst, 'что то там')  # значения ключей будет то, что мы указали после запятой
K.clear(K)  # метод для отчистки словаря
J = K.copy()  # метод для копирования данных словаря
D.get("babka",
      565)  # get - возвращает значение ключа, но если его нет, не бросает исключение, а возвращает default (по умолчанию None).
D.setdefault(3,
             'tree')  # метод если не записывать значение ключа, и этого ключа нет в словаре, внесет в  список ключ с неопределенным значением
D.pop(
    3)  # метод удаляет ключ из словаря, и возвращает значение ключа, для несушествующих ключей можно указать значение, которое вернет метод
D.popitem()  # удалит последнее значение в словаре
D.keys()  # возврвщает список ключей
D.values()  # возвращает список значений
D.update(
    K)  # значения имеющихся ключей если таковые есть будут перезаписаны, а если их нет, то добавлены в словарь (словарб обновится)
L = {**K,
     **D}  # создает словарь, в который будут входить ключи и значения входяших в него словарей (обЪединяем словари)
D.items()  # метод выведет пары ключ - значение в виде картежа

# Кортеж - упорядоченная но не изменяемая последовательность
T = 1, 2, 3, 4, 5, 6, 7  # Такой тип переменнной называется кортеж, он яввляется неизменяемым, тип данных-tuple
print(type(T))
a = T[0]  # вынимаем из картежа первую по порядку переменную
b = T[1]
a, b = (1, 2)  # a примет значение 1, а b значение 2
a, b, *rest = T  # Присваиваем a значение первой переменной кортежа, b- второй, в *rest же положим все остальные переменные
d = T[2:4]  # срез кортежа
s = (1,)  # метод записи картежа с одним элементом
F = T + d  # так можно обьединить значения кортежей
F += ("проверим", "метод",)  # добовляем в кортеж новые переменные
S = (0,) * 10  # дублируем элемент

S = (True, 10, [1, 2, 3], 'hello', {"мякиш": "хлеб"})
S[2].append(4)  # несмотря на то, что кортеж неизменяемый тип данных, мы можем менять внутри него изменяемые типы данных
# мы не можем менять ссылки переменных на данные, когда они уже определены
d = T[:]  # в отличии от списков не создаст новый  кортеж, а будет ссылаться на тот же самый
print(T)  # Выведет: 1, 2, 3, 4, 5, 6, 7
print(*T)  # Выведет: 1 2 3 4 5 6 7
print(*T, sep=":", end="!\n")  # Выведет: 1:2:3:4:5!

T.count(3)  # возвращает количество элементов с указанным значением
T.index(2)  # возвращает индекс первого найденого элемента
T.index(3, 4, 2)  # принцип (переменная, start, stop)
3 in T  # проверяем входит ли значение в кортеж

# Множества(set) - это неупорядоченная коллекция уникальных(не дублирующие) элементов
a = {1, True, (1, 3, 4), 'fuck'}  # внутри множеств нельзя указывать изменяемые типы данных
a = set()  # чтобы создать пустое множество нельзя указзывать a = {} - создастсяпустой словарь
a.add('goll')  # добовляем новый элемент в множество
a.update([1, 2.3323])  # добовляем несколько обьекто в множество
a.discard("fuck")  # удаляем из множества объект
a.remove('123')  # удаляет из можества объект, но если его не существует, выдает ошибку
a.pop()  # удаляет произвольный объект и возвращает его

setA = {1, 2, 3, 4}
setB = {1, 4, 5, 6}
setC = setA & setB  # операция позволяет находить общие элементы
setA.intersection(setB)  # тоже самое (операция обьединения)
setA.intersection_update(setB)  # множество А изменится и примет значение общей части множеств
setD = setA | setB  # обьединение множеств
setM = setA - setB  # элементы, которые есть только  множесте А, важно что от чего отнимать
setN = setA ^ setB  # элементы, которые есть и в том и в том множестве искючаются, а остальные выводятся (симметричная разность)
setA == setB  # сравнение на равенство
setS = setA <= setB  # проверяет, входитли ножество А в множество В

# генераторы множеств и словарей
m = {x ** 4 for x in range(5)}  # генератор множеств
m = {x ** 0.5: x ** 3 for x in range(10)}  # генератор словарей

# нужно ключи записать большими буквами, а значения сделать числами
m = {"неудл": 2, "удов": "3", "хор": "4"}
a = {key.upper(): int(poy) for key, poy in m.items()}  # .items позволяет вынимать из словарей и ключ и значение
# условия так же можно прописывать


# Функции
def send_main():  # обьявляем функцию(если нужно в скобках можно указать переменную)
    text = "Ну предположим, мне нужно проверить эту функцию"
    print(text)


send_main()  # вызываем функцию


def gamp(people): # если мы указали параметр, то обязательно должны передать аргумент
    text = f"{people} постоянно забывает то, что прошел и понял"
    print(text)


gamp("Игорь")

# если мы хотим возвратить какую либо переменную из функции, нам нужно явно указать ее при помощи return
# как тоько  встречается return функция завершает свою работу
# пример
def koren_2(x):
    res = None if x < 0 else x ** 0.5
    return res # за приделами функции, вывести перевенную не получится


a = koren_2(4)
print(a)

# Пример программы, выводит четные числа
def even(x):
    return x % 2 == 0


for a in range(0, 40):
    if even(a):
        print (a)


def get_nod(x, y):
    '''
    Вычисляется НОД для натуральных чисел по алгоритму евклида
    :param x: Первое натуральное число
    :param y: Второе натуральное число
    :return: НОД
    '''
    while x != y:
        if x > y:
            x -=y
        else:
            y -= x
    return x


a = int(input('\n'))
b = int(input())
print(get_nod(a, b))
print(help(get_nod)) # выведет описание функции

def get_per(a, b, c):
    print(f'a={a}, b={b}, c={c}')
    return a + b + c


print(v := get_per(b=2, c=4, a=1)) # такие аргументы называются именнованными, потому что явно соят имена параметров
# если совмещать позиционные и именные аргументы, вначале всегда дожны идти позиционные
# так же существуют формальные параметры - при создании функции мы сразу передаем ему какое-то значение. Остальные же называются фактическими

def get_form(a, b, formal=True):
    print(f'a={a}, b={b}')
    return a, b, formal


v = get_form(2, 3, False) # Изменяем формальный аргумент
print(v)


def os_peth(*args, **kwargs): # *имя переменной - для того,чтобы функция принимала произвольное число значений(передается как кортеж)
    # **имя перемнной - для того чтобы функция могла принимать произвольное число именнованных аргументов(передается как словарь)

    print(args, kwargs)


os_peth("F:\\", "windows\\", "igor\\game")


# * и ** - операторы упаковки и распоковки
*x, y, z = 1, 2, 3, 4, 4,5 # упаковка
a = ['as', 'assa', True, 6]
v = (*a,) # распоковка

# Рекурсивные функции
def recursive(value):
    print(value)
    if value < 10:
        recursive(value + 1)


recursive(1)

# lambda(анонимные функции) - может быть записана как любой элемент котструкции пайтон
S = lambda a, b: a + b
S(1, 2)


# JОбласти видимости переменных
D = 200

def ma_fun(arm):
    global D # обращаемся к глобальной переменной
    D = 20 # меняем глобальную переменную
    for x in arm:
        x = x + 20
        print(x)


ma_fun([1, 2, 3, 4])

x = 0


def outer():
    x = 1
    def inner():
        nonlocal x # X будет браться из внешней области видимости, то есть из функции outer
        x=2
        print(x)
    inner()
    print(x)
outer()
print(x)

# замыкание в пайтон - когда мы благодаря ссылке на локальную функцию, можем использовать переменные из внешних окружений
def my_cline(name):

    def my_stels():
        print(f"{name} разбирается с замыканием в пайтон")
    return my_stels # возвращаем ссылку на функцию


f = my_cline("Игорь") # записываем то, что возврощает функция(то есть ссылку на внутреннюю функцию)
f() # выполняем фцнкцию на которую ссылается переменная f
# так как мы ссылаемся на локальную функцию, сборщик мусора не отчищает данные в внешней функции и сохраняет все данные
# при каждом таком вызове функции создается свое пространство имен

# Декораторы функций
def deck_fucnck(func):
    def main(): # если хотим передать аргумент во внутреннюю функцию, необходимо его указать
        print('Что-то выполняется до функции')
        func() # указаваем аргумент который передаем
        print('Что то выполнняется после функции')
    return main


def func(): # если мы передаем что то в функцию, мы должны передать это и во внешнюю функцию
    print('Вызов функции ')

f = deck_fucnck(func)
f()

func = deck_fucnck(func) # можно записывать подобным образом
func() # так, функция меняет свою работу, она теперь не просто будет выводить что то в консоль но еще и будут выполняться дополнительные операции


# Чтобы сделать декоратор универсальным( на вход можно было подавать различное количество аргументов), можно сделать так:
def new_funk(funck):
    def steker_funk(*args, **kwargs):
        print('Что то делаем до функции')
        funck(*args, **kwargs)
        print('Что то делаем после функции')

    return steker_funk


def funck(*args, **kwargs):
    print("Работает ли функция:", *args, **kwargs)


funck = new_funk(funck)
res = funck('Захотел', 'я','написать')
print(res)


# Пример применения декораторов по алгоритму евклида
import time

def new_funk(funck):
    def steker_funk(*args, **kwargs):
        st = time.time()
        res = funck(*args, **kwargs)
        et = time.time()
        dt = et - st
        print(f'Время работы: {dt}')
        return res
    return steker_funk

@new_funk
def deep(x, y):
    while x != y:
        if x > y:
            x -= y
        else:
            y -= x
    return x

@new_funk
def test_funck():
    for a in range(1,100000):
        a += 1
    return a

#funck = new_funk(funck)
res = deep(324, 1212)
print(res)

new = test_funck()
print(new)


# Декораторы с параметрами
from functools import wraps # Декоратор
import math

def df_funk(dx = 0.1):
    def proizvodnaya_funk(funk):
        @wraps(funk) # Сохраняет имя функции и описание
        def wrapper(x, *args, **kwargs):
            res = (funk(x + dx, *args, **kwargs) - funk(x, *args, **kwargs)) / dx
            return res
        #wrapper.__name__ = funk.__name__ # Для того, что бы сохранить имя функции
        #wrapper.__doc__ = funk.__doc__ # Для того, что бы сохранить описание функции
        return wrapper

    return proizvodnaya_funk

@df_funk(dx = 0.0000001)
def sin_df(x):
    """Функция для вычисления производной"""
    return math.sin(x)

df = sin_df(math.pi/3)
print(df)
print(sin_df.__name__)
print(sin_df.__doc__)


# Работа с файлами
# Для того, чтобы работать с файлом, используется функция open("Указываем путь и имя файла")

file = open("tekst.txt", encoding="utf-8") # encoding - кодировка файла
print(file.read()) # прочитается все содержимое файла, и будут видны крокозябры, чтоб текст отображался корректно, нужно указать кодировку

# Если же мы хотим прочитать не весь фаил, а только часть, то нужно указать аргумент, сколько символов мы хотим прочиать
print(file.read(10)) # если после этого еще раз запустить чтение файла, то будут прочитаны следующие символы (с файловой позиции)

# чтобы обнулить файловую позицию, можно использовать функцию seek
file.seek(0) # следующее чтение начнется с 0 символа

# так же существует метод tell, который указывает файлувую позицию (стоит помнить что файловая позиция русского алфавита в utf-8 представляется 2 байтами, а символьная позиция указывает не номер символа, а номер байта)
pos = file.tell()

# если нужно прочитать первую строку, используется функция readline
line_1 = file.readline() # и конечным символом является \n
# при последующем вызове readline будут, выводиться следующие строки

print(file.readline(), end="")
# чтобы убрать \n вконце строки, можно указать аргумент end=""

# если читать фаил при помощи цикла for, то фаил будет выводиться построчно, то есть фаил будит рассматриваться как итерируемый обьект со строками
# если хотим вывести весь фаил, можно воспользоваться функцией readlines, которая вернет список, в котором переменными будут строки из файла
s = file.readlines()

# ОБЯЗАТЕЛЬНО!!! как только мы завершаем работу с файлом, его следует закрыть, методом close  без аргументов
file.close()

# для обработки исключний? при ошибке FileNotFoundError, существует группа операторов try / except / finally
# синтаксис имеет вид:
# try:
#     Блок оператора уритического кода
# except[исключение]:
#     блок операторов обработки исключений
# finally:
#     Блок операторов, всегда исполняемых незаисимо от возникновения исключений

# Пример
try: # Блок try работает таким образом, что если у нас в какой либо строчке возникает ошибка, то мы сразуже переходим к исключениям
    # И из-за этого возникает проблема того, что если фаил откроется, и после этого произойдет ощибка, он не будет закрыт, для этого добавляем try и finally
    file = open("tekst.txt", encoding="utf-8")
    try:
        s = file.readlines()
        s = int(s) # моделируем ощибку
        print(s)
    finally:
        file.close()
except FileNotFoundError:
    print("Невозможно открыть фаил(")
except: # исключение для всех остальных ошибок
    print("Ошибка при работе с файлом")

# Так же try / finally можно заменить на файловый менеджер контекста:

try:
    with open("tekst.txt", encoding="utf-8") as file: # фаил в любом случае будет закрыт
        s = file.readlines()
        print(s)
except FileNotFoundError:
    print("Невозможно открыть фаил(")
except: # исключение для всех остальных ошибок
    print("Ошибка при работе с файлом")
finally:
    print(file.closed) # проверка, закрыт фаил или нет

#...................................................................................................
# Выражения генераторы

a = (x ** 2 for x in range(6)) # Хранит в себе генератор, то есть все значения хранятся одновременно и образуются "на лету"
#...................................................................................................


#...................................................................................................
# Вызов исключений
# raise Имя_ошибки - позволяет вызвать исключение
# raise имя_ошибки("аргумент_для_описания_ошибки")

def error(s):
    if s < 0:
        raise ValueError("Укажи число > 0")
    else:
        print(s)

error(-10)
#...................................................................................................


#...................................................................................................

#...................................................................................................
# Проверка правильности утверждения
# assert - это проверка правильности кода

def error(s):
    assert s/1 == -s

error(-10)
#...................................................................................................

#...................................................................................................
# Функции - генераторы

def get_list():
    for x in [1, 2, 3, 4]:
        yield x

# здесь в цикле записан новый для нас оператор yield, который возвращает текущее значение x и «замораживает»
# состояние функции до следующего обращения к ней (в том числе и все локальные переменные).
# Именно так определяются функции-генераторы. Если мы сейчас ее вызовем:

d = get_list()
print(d)
#...................................................................................................

#...................................................................................................
# Функция map(), первым аргументом указывается ссылка на функцию, которая будет последовательно
# применяться к каждому элементу итерируемого обьекта
# Дважды пройти по коллекции map нельзя
# Можно использовать max, min, sum и т.д.

b = map(int, [1, 2, 3, 4])

for i in b:
    print(i, end=' ')

# Помимо функции int можно использовать любую другую функцию, которая принимает 1 аргумент, но нельзя забывать,
# что мы указываем ссылку на функцию

cities = ['Москва', 'Астрахань', 'Саратов', 'Ташкент']

c = map(lambda x: x[::-1], cities)
print(list(c))

# Так же можно преобразовывать строку вводимую пользователем в список
s = map(int, input().split())

a = list(s)
print(a)
#...................................................................................................

#...................................................................................................
# Функция filter
# filter(func, *iterables)
# которая служит для фильтрации (отбора) элементов указанного итерированного объекта.
# Работает она очень просто. Если функция func возвращает для текущего значения элемента True,
# то он будет возвращен, а при False – отброшен.

def pid(x):
    x = x.upper()
    return  ('М' in x)

c = ['Москва', 'Саратов', 'Кострома']
a = list(filter(pid, c))
print(a)

# Так же можно передывать в качестве итерируемого обьекта, другой filter
#...................................................................................................

#...................................................................................................
# Функция zip
# Она для указанных итерируемых объектов перебирает соответствующие
# элементы и продолжает работу до тех пор, пока не дойдет до конца самой короткой коллекции.

a = [1, 2, 3, 4]
b = [5, 6, 7, 8, 9, 10]
c = 'Python'

z = zip(a, b, c)

for x in z:
    print(x)

# или

z1, z2, z3, z4 = zip(a, b, c)
print(z1, z2, z3, z4, sep="\n")
#...................................................................................................

#...................................................................................................
# Аргумент key для сортировки коллекций по ключу
# key - это ключ, именно по возвращенным результатам функции пройдет сортировка

def key_sort(x):
    return x if x % 2 == 0 else 100 + x

a = [1, -2, 5, -4, 6, -8, -3, 5, 7]

b = sorted(a, key=key_sort)
print(b)
#...................................................................................................

#...................................................................................................
# Функции isinstance для проверки типов данных
# Возвращает true, если число вещественное, в данном примере

data = (4.5, 8.7, True, "книга", 8, 10, -11, [True, False])

s = 0
for x in data:
    if isinstance(x, float):
        s += x

print(s)
#...................................................................................................

#...............................................................    ....................................
# Функции all и any

# Если все значения равны True, то на выходе получаем True. Если же, хотя бы одно значение
# принимает False, то на выходе будет False:

a = [True, True, True, True]
print(all(a))


# False получается и для:
# bool(0)
# bool("")
# bool([])
# bool({})

# Функция any() работает похожим образом, но возвращает True, если встретилось хотя бы одно
# такое значение. Например, для списка:
# мы увидим значение True. А вот если передать список со всеми False, то только в этом случае она вернет False.

any([False, False, False, False])
#...................................................................................................

#...............................................................    ....................................
# Расширенное представление чисел

a = 5e2 # =500

#Здесь e2 – это 10 в квадрате, то есть, 100 и оно умножается на 5, получаем 500. Причем, обратите
# внимание, число 500 представляется как вещественное, а не целое.

#Аналогичным образом можно задать и второе значение 0,01 как:

b = 1e-2 # = 0.01

#Здесь e-2 – это 10 в минус второй степени, то есть, 0,01 и все умножается на 1. Причем, единичка вначале строго
# обязательна – это формат записи чисел: сначала идет число, которое умножается на степень десятки.

avagadro = 6.02e23 # Число Авагадро 6.02 * 10^23

# Десятичное представление чисел
# 123 = 1*10^2 + 2*10^1 + 3*10^0  - В десятичной записи
# 001 = 0*2^2 + 0*2^1 + 1*2^0 = 1 - Перевод из двоичной записи в десятичную
# 1A = 1*16^1 + A*16^0 - = 26 - Перевод из шеснадцатеричной записи в десятичную
# bin(a) - Перевод в двоичную запись

dvoich_zap = 0b001 # - двоичная запись числа = 1 в десятичной записи
dvoich_zap_otr = -0b001 #- отрицательное число

shes = 0x1A # Запись числа = 26 в шеснадцатеричной системе

# Битовая операция И

flags = 5
mask = 4

if flags & mask == mask:
         print("Включен 2-й бит числа")
else:
         print("2-й бит выключен")

# x = x >> 1 - битовый сдвиг вправо, делит число на 2
# x = x >> 2 - битовый сдвиг вправо, делит число на 4

# x = x << 1 - битовый сдвиг влево, умножает число на 2
# x = x << 2 - битовый сдвиг влево, умножает число на 4
#...................................................................................................

#...............................................................    ....................................
# Модуль random стандартной библиотеки

import random

a_n = random.uniform(1, 5) # Случайное число от 1 до 5 включительно, вещественные числа тоже

a_m = random.randint(-3, 7)   # [-3; 7], целочисленные значения

a_g = random.gauss(0, 3.5) # Распледеление по гаусу, где 0 - мат ожидание, 3.5 - среднеквадратическое отклонение

lst = [4, 5, 0, -1, 10, 76, 3]
a = random.choice(lst) # После запуска видим случайно выбранное значение из списка lst

random.shuffle(lst) #  функция shuffle() перемешивает элементы списка случайным образом

a_s = random.sample(lst, 3) # Третья функция sample() возвращает новый список с указанным числом неповторяющихся
# элементов, выбранных случайным образом из списка

random.seed(123) # зерно, для того чтобы постоянно генерировалась одна и та же последовательность чисел

a_p = [random.randint(0, 10) for i in range(20)]
#...................................................................................................

#...................................................................................................
# Аннотация базовыми типами

cnt: int = 2 # Не выдаст ошибку, если сделать ссылку на вещественное число, но пометит

cnt = 5
cnt = 4.5
#..............................................................

def mul(x: int):
    x = x*2
    return x

print(mul('s')) # Выделит что ожидается int

#..............................................................
def mul(x: int, y: int = 2) -> float: # -> float - указывает что return - float
    x = x * y
    return x

print(mul.__annotations__) # показвает какой тип у обьектов функции

#..............................................................
from typing import Union, Optional, Any, Final

def mul(x: Union[int, float], y: Union[int, float] = 2) -> Union[int, float]: # Может принимать и int и float
    x = x * y
    return x

print(mul(45.4, 'da'))
print(mul.__annotations__)
#...................................................................................................

#...................................................................................................
# Конструкция match/case