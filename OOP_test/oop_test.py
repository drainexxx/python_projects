#..........................................................................................................................
# Введение в ООП

# pass - указывает на то, что в классе ничего не определяем
# class Point:
#     pass
#
# class Point_1: # В классе определяем 2 атрибута
#     color = "Blue"
#     circle = 2
#     size = 15
#
# print("Спрашиваем чему равен атрибут circle:", Point_1.circle) # Так мы можем обращаться к атрибуту класса
#
# Point_1.color = "red" # И так можем обращаться через класс к атрибутам
# print("Спрашиваем чему равен атрибут color:", Point_1.color)
#
# print("Спрашиваем какие атрибуты есть у класса:", Point.__dict__) # Таким образом можно увидеть все атрибуты класса
#
# a = Point_1() # Создаем экземпляр класса
# a.color = "black" # Задаем значение атрибуту
#
# print(getattr(Point_1, 'a', False)) # При обращении к атрибуту класса выведет False, если его не существует, если существует,
# # то выведет значение атрибута
#
# del Point_1.size # Удаляет атрибут класса, выведет ошибку если попробовать удалить несуществующий атрибут
#..........................................................................................................................


#..........................................................................................................................
# class Point:
#     "Даннный класс нужет для представления точек на плоскости" # Так можно описать класс
#     color = "red"
#     size = 20
#     circle = 2
#
# a = Point()
# b = Point()
#
# print(a.color) # Мы можем обращаться к атрибутам класса
# print(b.size)
# print(a.color)
# print(b.size)
#
# b = Point()
#
# print("Point:", Point.__dict__)
# print("a:", a.__dict__)
# print("b:", b.__dict__)
# print(Point.__dict__)
# print("Описание классса Point:", Point.__doc__) # Вызываем описание класса метдом __doc__
#..........................................................................................................................


#..........................................................................................................................
# Функция как атрибут класса

# class Point:
#     "Даннный класс нужет для представления точек на плоскости"
#     color = "red"
#     size = 20
#     circle = 2
#
#     def Set_Collors(self, x, y):
#         print('Вызов метода Set_Collors')
#         self.x = x
#         self.y = y
#
#     def get_coords(self):
#         return (self.x, self.y)


# Если мы хотим внутри класса определить метод, который можно было бы вызывать из его экземпляров,
# то дополнительно прописывается первый параметр, обычно, с именем self
# Self - это имя обьекта класса, ссылка на него, это нужно для обратной связи
# self передается первым аргументом

# pt = Point()
# pt.Set_Collors(1, 2) # Вызаваем функцию
# print(pt.__dict__) # Какие атрибуты есть у объекта класса
# print(pt.get_coords()) # Вызаваем функцию
#..........................................................................................................................


#..........................................................................................................................
# Инициализатор __init__ и финализатор __del__

# class Point:
#     "Даннный класс нужет для представления точек на плоскости"
#     color = "red"
#     size = 20
#     circle = 2
#
#     def __init__(self, a: int = 0, b: int = 0): # __init__ - Магический метод, который вызывается сразу после создания экземпляра класса
#         print("Вызов __init__")
#         self.x = a
#         self.y = b
#         print(f"Значение x = {a} \nЗначение y = {b} ")
#     def __del__(self): # __del__ - Магический метод, который вызывается сразу после удаления экземпляра класса
#         print(f"Ну и зачем удаляешь экземпляр класса: {self}")
#
# pt = Point(1, 2)
# print(pt.__dict__)
#
# del pt
#..........................................................................................................................


#..........................................................................................................................
# Магический метод __new__. Пример паттерна Singleton(Сингвитон)
# __new__ - Вызывается перед созданием объекта класса
# функция super() возвращает ссылку на базовый класс и через нее мы вызываем метод __new__ с одним первым аргументом
# cls - ссылается на класс

# class Point:
#     def __new__(cls, *args, **kwargs):
#         print(f'Вызов __new__ для: {cls}')
#         return super().__new__(cls)

#     def __init__(self, x = 0, y = 0):
#         print(f'Вызов __init__ для: {self}')
#         x = x
#         y = y
#         print(self.__dict__)
#
# flex = Point()


#Пример паттерна Singleton

# class DataBase:
#     __instance = None
#
# #...............................................................
# # Сам патерн Singleton
#     def __new__(cls, *args, **kwargs):
#         if cls.__instance is None:
#             cls.__instance = super().__new__(cls)
#
#         return cls.__instance
#
#     def __del__(self):
#         DataBase.__instance = None
#
# # ...............................................................
#     def __init__(self, user, psw, port):
#         self.user = user
#         self.psw = psw
#         self.port = port
#
#     def connect(self):
#         print(f"соединение с БД: {self.user}, {self.psw}, {self.port}")
#
#     def close(self):
#         print("закрытие соединения с БД")
#
#     def read(self):
#         return "данные из БД"
#
#     def write(self, data):
#         print(f"запись в БД {data}")
#
#
# db = DataBase('root', '1234', 80)
# db2 = DataBase('root2', '5678', 40)
# print(id(db), id(db2))
#
# db.connect()
# db2.connect()
#
# print(db.__doc__)
# print(db2.__doc__)
#..........................................................................................................................


#..........................................................................................................................
# Методы класса (classmethod) и статические методы (staticmethod)

# Определяются с помощью декораторов: @classmethod и @staticmethod
# @classmethod - может обращаться только к атрибутам самого класса
# @staticmethod - ни имеет доступа ни к атрибутам экземпляров классов, ни к атрибутам самих классов, то есть создается
# самостоятельная, независимая функция обьявленная внутри класса

# class Vector:
#     MIN_COORD = 0
#     MAX_COORD = 1000
#
#     @classmethod
#     def validate(cls, arg):
#         return cls.MIN_COORD <= arg <= cls.MAX_COORD # Обращаемся к атрибутам класса через ссылку cls, это значит, что
#     # мы не сможем обращаться к атрибутам экземпляра класса
#
#     def __init__(self, x, y):
#         self.x = self.y = 0
#         if Vector.validate(x) and Vector.validate(y): # Проверка на x и y, должны быть в диапазоне от 0 до 1000
#
#         # Более универсально:
#         # if self.validate(x) and self.validate(y): # Если изменить имя класса, все равно будет работать
#         # Почему работает? Дело в том что self это ссылка на экземплял класса, в котором хранится информация о самом классе,
#         # и интерпритатор понимает, ссылку на какой класс нужно поставить
#
#             self.x = x
#             self.y = y
#
#     def get_coord(self):
#         return self.x, self.y
#
#     @staticmethod # Статический метод предполагается использовать с конкретными параметрами
#     def norm2(x, y): # Нет никаких скрытых параметров
#         return x * x + y * y

#..................................
# Можно обратиться таким образом:

# v = Vector(1, 2)
#
# print(Vector.validate(5)) # Вызываем без каких либо дополнительных ссылок, не можем использовать для изменения экз. класса
#
# print(Vector.norm2(5, 4))
# rov = Vector.get_coord(v)
# print(rov)
#..........................................................................................................................


#..........................................................................................................................
# Инкапсуляция. Режимы доступа public, private, protected. Сетты и геттеры

# _atribute - режим доступа protected
# __atribute - режим доступа private

# protected - служит для обращения внутри класса и во всех его дочерних классах
# private - служит для обращения только внутри класса

# class Point:
#     def __init__(self, x = 0, y = 0):
#         self._x = x
#         self._y = y
#
# pt = Point(1,2)
# print(pt._x, pt._y) # Все еще можем обращаться из вне, но что тогда меняется?
# # В python нижнее подчеркивание лишь сигнализирует что св-во является защищенным
#............................

#............................
# # Модуль accessify, а так же __atribute - режим доступа private
# # Следует использовать когда нужно защитить методы
#
# from accessify import private, protected # Импортируем два декоратора
#
# class Point:
#     def __init__(self, x = 0, y = 0):
#         if self.__check_value(x) and self.__check_value(y):
#             self.__x = x
#             self.__y = y
#
#     @private # Декоратор из модуля accessify, который делает метод по настоящему защищенным
#     @classmethod
#     def __check_value(cls, x):
#         return type(x) in (int, float)
#
#     def set_cord(self, x, y):
#         if self.__check_value(x) and self.__check_value(y):
#             self.__x = x
#             self.__y = y
#         else:
#             raise ValueError("Координаты должны быть числами")
#
#     def get_cord(self):
#         return self.__x, self.__y
#
#
# pt = Point(1, 2)
# pt.set_cord(10, 20) # сеттер, для ввода
# print(pt.__dict__)
#
# # Если попробовать обратиться к __x и __y, то выдаст ошибку:
# # print(pt.__x, pt.__y)
#
# # Если же указать в следующем виде, то доступ можно получить:
# print(pt._Point__x, pt._Point__y)
#
# print(pt.get_cord()) # геттер, для вывода результата

#..........................................................................................................................


#..........................................................................................................................
# Работа с атрибутами класса и из экземплярами

# class Point:
#     MAX_CORD = 100
#     MIN_CORD = 0
#
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def set_cord(self, x, y):
#         if self.MAX_CORD <= x <= self.MAX_CORD:
#             self.x = x
#             self.y = y
#
#     @classmethod
#     def set_bound(cls, left): # Таким образом можно менять атрибут в самом классе
#         cls. MIN_CORD = left
#
# pt1 = Point(10, 20)
#
# pt1.set_bound(-100)
# print(Point.MIN_CORD)
# print(pt1.MIN_CORD) # python не находит в экземпляре класса атрибут, поэтому начинает искать в самом классе и находит его
#..........................................................................................................................


#..........................................................................................................................
# Магические методы для атрибутов

# __setattr__(self, key, value)__ – автоматически вызывается при изменении свойства key класса;
# __getattribute__(self, item) – автоматически вызывается при получении свойства класса с именем item;
# __getattr__(self, item) – автоматически вызывается при получении несуществующего свойства item класса;
# __delattr__(self, item) – автоматически вызывается при удалении свойства item (не важно: существует оно или нет).

# class Point:
#     MAX_CORD = 100
#     MIN_CORD = 0
#
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def set_cord(self, x, y):
#         if self.MIN_CORD <= x <= self.MAX_CORD and self.MIN_CORD <= y <= self.MAX_CORD:
#             self.x = x
#             self.y = y
#
#     def __getattribute__(self, item): # Автоматически срабатывает при считывании атрибута, через экземплял класса.
#         # item - атрибут, к которому идет обращение.
#         # Следующим образом можно закрыть доступ к конкретным атрибутам:
#         if item == 'x':
#             raise ValueError('доступ запрещен')
#         else:
#             return object.__getattribute__(self, item) # Обращаемся к object от которого наследуются все классы
#
#     def __setattr__(self, key, value): # Автоматически срабатывает, когда идет присваивание
#                                     # какому-либо атрибуту значения
#         print("__setattr__ сработал")
#         object.__setattr__(self, key, value) # При отработке кода, создастся 4 сообщения,
#         # это происходит из-за того что мы 2 раза создали экземпляры класса и 2 раза опредилили значения
#         # для каждого из классов
#
#     def __getattr__(self, item): # Вызывается, когда пытаемся обратиться к несуществующему атрибуту класса
#         print('нет такого атрибута')
#
#     def __delattr__(self, item):
#         print("__delattr__ сработал")
#         object.__delattr__(self, item)
#
# pt1 = Point(1, 2)
# pt2 = Point(1, 2)

# a = pt1.x # чтобы увидеть что при обращению к атрибуту класса срабатывает магический метод __getattribute__

# print(pt2.yy) # чтобы проверить, как работает __getattr__

# del pt1.x # чтобы проверить, как работает __delattr__
#..........................................................................................................................


#..........................................................................................................................
# Свойства property. Декоратор @property
# property - устроен так, что при чтении данных вызывается первый переданным метод, а при записи второй

class Person:
    def __init__(self, name, old):
        self.__name = name
        self.__old = old

    def get_old(self): # Так как приватное свойство, выводим его с помощью гетера
        return self.__old

    def set_old(self, old): # Так как свойство приватное, можем менять только при помощи сеттеров
        self.__old = old

    old = property(get_old, set_old) # Запись сво-ва property


p = Person('Никита', 20)
p.old = 30
print(p.old, p.__dict__)

















